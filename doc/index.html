<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.28
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><div align="center">

# *Address Detective*

### _Transform your command-line into a Sherlock Holmes of sorts, capable of solving the mystery of any US address! Build a program that harnesses the power of an API to validate the authenticity of a US address, revealing its true identity or boldly declaring it 'Invalid'. Get ready to don your detective cap and solve the case of the US Address!_

<u>

## Table of Contents
</u>

[Setup / Installation](#setup--installation)<br>
[Running the Program](#running-the-program)<br>
[Testing](#testing)<br>
[Reasoning and Decision Making](#reasoning-and-decision-making)<br>
[Gems](#gems)<br>
[Testing](#testing)

<u>

_ENVIRONMENT_
</u>
</div>
<p>This project used the <img src="https://img.shields.io/badge/Ruby-CC342D?style=for-the-badge&logo=ruby&logoColor=white"> <code>VERSION 3.1.2</code> and was developed/tested with <img src="https://img.shields.io/badge/mac%20os-000000?style=for-the-badge&logo=apple&logoColor=white"> <code>VENTURA 13.2.1</code> <br></p>

<p>&lt;u&gt;</p>

<h2 id="label-Setup+-2F+Installation">Setup / Installation</h2>

<p>&lt;/u&gt;</p>
<ul><li>
<p>Please note, any time <code>$</code> is in the command line prompt, that is to signify the beginning of a terminal command, do not include the <code>$</code> in the input</p>
</li><li>
<p>To install the necessary software to run a ruby program, please follow the sub points below:</p>
</li><li>
<p>To install a version manager such as <code>rbenv</code> to easily switch between <code>Ruby</code> versions <a href="https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-with-rbenv-on-macos">rbenv tutorial</a></p>
</li><li>
<p>Once a version manager is installed, install ruby using <code>$ rbenv install 3.1.2</code></p>
</li><li>
<p>To install a bundler for the gems already in the file, run that by inputting <code>$ gem install bundler</code></p>
</li></ul>

<p><em>Now you are ready to move forward with this repo!</em></p>
<ul><li>
<p>Clone this Git repository to your local machine <a href="https://github.com/RyanChrisSmith/address_detective">here</a></p>
</li><li>
<p><code>$ cd address_detective</code> into the repo</p>
</li><li>
<p>Run <code>$ bundle install</code> to add all the gems</p>
</li><li>
<p>Well, well, well, it looks like we have a secret agent in our midst! There’s an API Key involved that’s so top-secret, it doesn’t even come with the repo! Gotta keep those classified files under lock and key, am I right?</p>
</li><li>
<p>Go to <code>https://www.smarty.com/products/us-address-verification</code> to get an <code>API key</code> and <code>Authorization token</code>, you will need this and once back I can direct you as to where they can go on your machine to stay safe and sound.</p>
</li><li>
<p>Create a file <code>$ touch .env</code> which should create an empty <code>.env</code> file at the root level of the files</p>
</li><li>
<p>In that <code>.env</code> file add your keys as pictured below, but put the keys in the spaces that are scratched out.</p>
</li></ul>

<p>&lt;img src=“images/screenshot.png”&gt;</p>
<ul><li>
<p>Make sure to label the keys exactly the same as in the screenshot <code>SMARTY_AUTH_ID</code> and <code>SMARTY_AUTH_TOKEN</code> so that the keys will work properly when the program is run</p>
</li><li>
<p>ONE LAST THING BEFORE YOU GO ANYWHERE! We have to protect <em>YOUR</em> keys too! Make sure to add <code>.env</code> file to your <code>.gitignore</code> file like pictured below</p>
</li></ul>

<p>&lt;img src=“images/screenshot-2.png”&gt;</p>
<ul><li>
<p>This way, the API keys will stay out of the commit history keeping them safe from prying eyes</p>
</li><li>
<p>If the preference is to see the documentation for all public methods' args and return types, there are some YARD documentation created to see just that. See explanation of gems used <a href="#gems-why-these-ones">below</a> or go to the <a href="https://github.com/lsegal/yard">yard gem page</a></p>
<ul><li>
<p>In the terminal, run <code>$ yard server</code> and then go to url <code>http://localhost:8808/</code> in a browser window.</p>
</li><li>
<p>Feel free to click around on the different classes and see what each method in each class is doing</p>

<h3 id="label-Back+to+Table+of+Contents"><a href="#table-of-contents">Back to Table of Contents</a></h3>
</li></ul>
</li></ul>

<p>&lt;u&gt;</p>

<h2 id="label-Running+the+Program">Running the Program</h2>

<p>&lt;/u&gt;</p>
<ul><li>
<p>Once setup / installation is finished, it is time to run this beautiful program from your terminal</p>
</li><li>
<p>Run <code>$ ruby runner.rb data/test_addresses.csv</code></p>
</li><li>
<p>The response you should see in the terminal will look like this:</p>

<pre class="code ruby"><code class="ruby">143 e Maine Street, Columbus, 43215 -&gt; 143 E Main St, Columbus, 43215-5370
1 Empora St, Title, 11111 -&gt; Invalid Address
24 Second Avenue, San Mateo, 94401 -&gt; 24 2nd Ave, San Mateo, 94401-3828
24 Second Avenue, San Mateo, 84405 -&gt; Invalid Address
800 Middle Avenue, Menlo Park, 94025-9881 -&gt; 800 Middle Ave, Menlo Park, 94025-5121
500 Arbor Road, Menlo Park, 94025 -&gt; 500 Arbor Rd, Menlo Park, 94025-5132
123 N. Elm St, Springfield, 65802 -&gt; Invalid Address
123 South Elm St, Springfield, 65802 -&gt; Invalid Address
1 Main St, New York, 10001-1111 -&gt; 1 Main St, New York, 10044-0052
1234 Random Rd, Smallville, 1234 -&gt; Invalid Address
123 Long Street, City, ABCDE -&gt; Invalid Address
1234 Second Street, Big City, 1234567 -&gt; 1234 Second Street, Schenectady, 12345-0001
</code></pre>
</li><li>
<p>Steps behind the scenes:</p>
</li><li>
<p>The program is reading from a static CSV file</p>
</li><li>
<p>Creating individual addresses out of each line</p>
</li><li>
<p>Sending that to a 3rd party API to verify the address</p>
</li><li>
<p>Receiving a response from the API of whether its valid or not</p>
<ul><li>
<p>If it is valid it is giving you the official address with appropriate corrections</p>
</li></ul>
</li><li>
<p>Then showing that response after the lamda or <code>-&gt;</code> with either the <em>corrected address</em> or <code>Invalid Address</code></p>
</li></ul>

<h2 id="label-EXTENSION"><strong><em>EXTENSION</em></strong></h2>
<ul><li>
<p><em>The API allows for bulk address looks ups beyond the single address method</em></p>
<ul><li>
<p><em>This does require some adjustments on where information is passed in the API call, such as headers and in the body, so pay close attention to the difference in the way the code is written</em></p>
</li></ul>
</li><li>
<p><em>This program will allow for that in the same command line you just did, but with a much larger file</em></p>
</li><li>
<p><em>Run <code>$ ruby runner_bulk.rb data/test_bulk_addresses.csv</em></code></p>
</li><li>
<p><em>This allows for 100 addresses OR 32k worth of data to be requested in one call! Awesome!</em></p>
</li><li>
<p><em>The results will look quite similar to the single address look up from above, but the list will be much longer (to save space, that was not added on this README)</em></p>
</li></ul>

<h3 id="label-Back+to+Table+of+Contents"><a href="#table-of-contents">Back to Table of Contents</a></h3>

<p>&lt;u&gt;</p>

<h2 id="label-Reasoning+and+Decision+Making">Reasoning and Decision Making</h2>

<p>&lt;/u&gt;</p>

<p>This program is an example of how to use various programming concepts, libraries, and APIs to build a tool that validates and corrects addresses using the SmartyStreets API.</p>

<p>At a high level, the program reads in a CSV file containing addresses, creates CsvAddress objects to represent each address, validates and corrects each address using the SmartyStreetsApi API, and outputs the corrected address via the ResponseConverter in the console.</p>

<p>The code provided includes five classes, each with its own responsibility. Here is an overview of each class alphabetically and its design decisions:</p>
<ul><li>
<p>ApiAddress class - This class represents an address returned from a third-party API. It has five attributes: street, city, zip, plus4_code, and index. The street, city, zip, and plus4_code are required attributes, and the index is an optional attribute. The class has an initializer that accepts the required attributes as arguments and sets them as instance variables. The initializer also sets the index attribute to nil if it is not provided. The validated method returns the full address as a string in the format "street, city, zip-code plus4-code". The design decision here is to have a separate class to represent an address returned from the API. This class encapsulates the data returned from the API and provides a way to access and validate that data.</p>
</li><li>
<p>CsvAddress class - This class represents an address in a CSV file. It has three attributes: street, city, and zip_code. The street, city, and zip_code are required attributes, and the class has an initializer that accepts these attributes as arguments. The initializer validates that the arguments are not empty or nil, sets them as instance variables after stripping whitespace, and raises an ArgumentError if any of them are blank. The complete method returns the full address as a string in the format "street, city, zip_code". The design decision here is to have a separate class to represent an address in a CSV file. This class encapsulates the data from the CSV file and provides a way to validate and format the data.</p>
</li><li>
<p>CsvReader class - This class reads addresses from a CSV file and returns an array of CsvAddress objects. The class uses the CSV library to read the file and the CsvAddress class to create objects for each row in the file. The CSV.foreach method is used to iterate over the rows in the file and convert each row into a CsvAddress object using the CsvAddress.new method. The design decision here is to have a separate class to read CSV files and create CsvAddress objects. This class encapsulates the logic of reading the file and creating objects.</p>
</li><li>
<p>ResponseConverter class - This class converts response data from the SmartyStreets API into ApiAddress objects. The class has two methods: single and bulk. The single method takes a single address from the API response and creates an ApiAddress object from the data. The bulk method takes a list of addresses from the API response and creates a list of ApiAddress objects. Both methods extract the necessary data from the response and pass it to the ApiAddress.new method to create the objects. The design decision here is to have a separate class to convert the API response data into ApiAddress objects. This class encapsulates the logic of extracting the necessary data and creating objects.</p>
</li><li>
<p>SmartyStreetsApi class - This class makes requests to the SmartyStreets API, which is used to confirm the validity of addresses. This class provides a convenient way to interact with the SmartyStreets API and confirm the validity of addresses. It has two public class methods and one private class method.</p>
</li><li>
<p>The first public class method confirm_address takes three arguments street, city, and zip_code, representing the address to be confirmed, and makes a GET request to the SmartyStreets API to confirm its validity. It returns a hash containing the response from the API.</p>
</li><li>
<p>The second public class method bulk_addresses takes an array of hashes as an argument, where each hash represents an address containing the keys :street, :city, and :zip_code. It then makes a POST request to the SmartyStreets API to confirm the validity of all the addresses in bulk. It returns a hash containing the response from the API.</p>
</li><li>
<p>The private class method conn sets up a connection to the SmartyStreets API using the Faraday gem. It returns a Faraday connection object with the base URL, authentication credentials, and candidate limit set. This method is used by the two public methods to make requests to the API.</p>
</li></ul>

<p>Overall, this program demonstrates how to use OOP principles, libraries, and APIs to build a tool that solves a specific problem: validating and correcting addresses. By following the Single Responsibility Principle, the program is easier to understand, easier to maintain, and easier to modify. Plus, it helps to avoid the dreaded “spaghetti code” - code that’s so intertwined and convoluted that it’s hard to tell what’s going on.</p>

<h3 id="label-Back+to+Table+of+Contents"><a href="#table-of-contents">Back to Table of Contents</a></h3>

<p>&lt;u&gt;</p>

<h2 id="label-Gems+-28Why+these+ones-3F-29">Gems (Why these ones?)</h2>

<p>&lt;/u&gt;</p>

<p><a href="https://github.com/rubysec/bundler-audit">Bundler Audit</a> - used to scan a Ruby project’s dependencies for known vulnerabilities and security issues</p>

<p><a href="https://github.com/bkeepers/dotenv">DotEnv</a> - loads environment variables from a .env file into the environment of a Ruby application, making it easy to manage sensitive configuration information such as API keys, passwords, and database credentials in a secure way without hardcoding them in the codebase.</p>

<p><a href="https://github.com/pry/pry">Pry</a> - provides a more powerful and interactive REPL (Read-Eval-Print Loop) console for debugging and exploring Ruby code.</p>

<p><a href="https://github.com/rubocop/rubocop">Rubocop</a> - provides a static code analyzer to enforce consistent coding style, best practices, and detect potential issues in a Ruby codebase.</p>

<p><a href="https://github.com/rspec">RSpec</a> - framework for writing and executing tests to ensure the expected behavior of a Ruby codebase.</p>

<p><a href="https://github.com/simplecov-ruby/simplecov">Simplecov</a> - provides code coverage analysis for a Ruby codebase.</p>

<p><a href="https://github.com/vcr/vcr">VCR</a> - provides a way to record and replay HTTP interactions between a Ruby application and an external API. This gem depends on WebMock (next gem) to intercept HTTP requests and responses, and provide the necessary stubbing and recording capabilities.</p>

<p><a href="https://github.com/bblimke/webmock">WebMock</a> - provides a way to stub HTTP requests and responses in Ruby tests</p>

<p><a href="https://github.com/lsegal/yard">Yard</a> - documentation generation tool for Ruby code that simplifies the process of creating high-quality API documentation.</p>

<h3 id="label-Back+to+Table+of+Contents"><a href="#table-of-contents">Back to Table of Contents</a></h3>

<p>&lt;u&gt;</p>

<h2 id="label-Testing">Testing</h2>

<p>&lt;/u&gt;</p>
<ul><li>
<p><em>If you would like to run the test suite</em></p>
</li><li>
<p>Run <code>$ bundle exec rspec</code> to execute the whole test suite</p>
</li><li>
<p>You will notice beyond the passing tests that <code>simplecov</code> is generating a Coverage Report. This helps to identify any code that was written is actually being tested. You can <code>$ open coverage/index.html</code> to see a visual representation of what is being covered.</p>
</li><li>
<p><em>If you would like to check the code for any known vulnerabilities</em></p>
</li><li>
<p>Run <code>$ bundle audit check --update</code></p>
</li><li>
<p>Using the update flag makes sure that the gem is checking with the most recently known advisories and vulnerabilities</p>
</li><li>
<p><em>There should be a fixtures folder within the spec folder</em></p>
</li><li>
<p>That is there courtesy of the VCR gem</p>
</li><li>
<p>These are the recordings of the original API call that are then used in the subsequent times running the tests. This way, the actual API calls are limited after the test has been run the first time.</p>
</li><li>
<p>There is a cassette tape for every test that has <code>:vcr</code> in its <code>it</code> block description</p>
</li><li>
<p>See below for a more specified explanation of each test file for each class</p>
</li></ul>

<p>The code is a set of RSpec tests to test classes CsvAddress, CsvReader, and ResponseAddress for validating and processing addresses.</p>

<p>The CsvAddress class is tested to ensure that it is initialized with valid attributes (street, city, zip_code) and will create an object for each address from a CSV file, even if it has incomplete or whitespace values. It is also tested to return the complete address as a string and to raise an ArgumentError if any attributes are empty.</p>

<p>The CsvReader class is tested to ensure that it can retrieve all addresses from a test CSV file and return them as CsvAddress objects with the correct values for each attribute.</p>

<p>The ResponseAddress class is tested by sending a request to the SmartyStreets API to confirm an address, and then verifying that it returns the correct full response, street, city, and zip code attributes. It is also tested to return ‘Invalid Address’ if the csv address doesn’t exist. The tests use a gem called VCR to record and replay HTTP interactions with the API.</p>

<p>The SmartyStreetsApi tests contains two main blocks: “happy path” and “sad path”. The “happy path” block tests that the SmartyStreetsApi.confirm_address method returns the expected result when given valid input. It also uses VCR to record and replay the HTTP request/response interaction with the SmartyStreets API, so that the tests can be run repeatedly without hitting the API every time. The “sad path” block contains several test cases that simulate various error scenarios that can occur when using the SmartyStreetsApi.confirm_address method. These include testing for connection errors, timeout errors, invalid JSON responses, and various HTTP error responses, such as 401 Unauthorized, 402 Payment Required, and 500 Server Error. The tests use RSpec’s expect and raise_error matchers to verify that the correct error is raised under each scenario.</p>

<p><strong>EXTENSION TESTING</strong> The ResponseBulkAddress first test verifies that an array of correct ResponseBulkAddress objects is returned after a bulk API call. The second test verifies that each instance of ResponseBulkAddress has the correct instance variables. The third test verifies that if an address does not exist, no data is returned at the index point of that address in the original array. The final test checks that the complete method of ResponseBulkAddress returns the full address in one string.</p>

<p>Unlike the single address check used previously, the API does not return anything when the address is “Invalid” when checking in bulk. A check was created in the runner_bulk file to compare index values of the initial request to the response values, if there was a missing index in the return that indicated that it was invalid thus indicating an ‘Invalid Address’</p>

<h3 id="label-Back+to+Table+of+Contents"><a href="#table-of-contents">Back to Table of Contents</a></h3>

<p>&lt;u&gt;</p>

<h2 id="label-Extension+Ideas">Extension Ideas</h2>

<p>&lt;/u&gt;</p>
<ul><li>
<p>Wrap error handling for third party API responses to future proof for versions 2 and beyond</p>
</li><li>
<p>Write a CSV file for output rather than just in command line</p>
</li><li>
<p>Handling other file types for initial input (pdf, json, yaml, xml)</p>
</li><li>
<p>Error handling for input file issues (wrong headers, no commas, too many commas, weird encoding, strange characters, extra comma(s) in street attribute)</p>
</li></ul>
</div></div>

      <div id="footer">
  Generated on Thu Apr  6 10:17:01 2023 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.28 (ruby-3.1.2).
</div>

    </div>
  </body>
</html>